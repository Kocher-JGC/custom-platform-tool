[[toc]]

# 平台组件接入规则

## 1. Changelog

| 作者 | 更新日期 | 版本 | 更改内容 |
|---|---|---|---|
| 相杰 | 2020-11-16 | v1.0.0 | 初稿 |
| 相杰 | 2020-11-29 | v1.1.0 | 1. 完善平台组件接入的描述<br>2. 添加对于页面数据的描述<br> |
| 相杰 | 2020-11-30 | v1.1.1 | 1. 完善文档描述 |

## 2. 编写目的和范围

1. 平台组件的渐进式接入指南
   1. 初级开发接入普通业务组件和属性项
2. 了解页面设计器的内部数据结构
   1. 页面设计器提供的修改数据的 API

---

## 3. 术语

| 术语 | 解释 |
|---|---|
| 平台组件 | 接入整个平台的组件，只需要接入一次，即可在配置端和应用端使用 |
| 平台 | 指整个平台，从配置到应用的全生命周期 |

---

## 4. 知识

### 4.1. 工程目录

在工程中，以下前缀的包对应不同的能力：

- `packages/`
  - `platform-widget-access-spec` 平台接入标准，提供 `SDK` 和 `interface`。
  - `platform-widget-hub` 平台组件开发的工作区。
  - `platform-widget-prop-item-hub` 属性项开发的工作区。
  - `platform-widget-access-loader` 平台组件 `loader`，用于加载组件数据的 `API`。
  - `platform-widget-access-prop-rely` 平台组件与属性项的依赖关系，只在`配置端`使用，`应用端`不需要。
  - `platform-widget-custom-editor-hub` 自定义的平台组件的属性编辑器，当遇到难以扩展的属性项编辑时，预留扩展的。

### 4.2. 平台的影响

由于平台组件运行在两个环境，分别是 `配置端` 和 `应用端`，开发组件时需要结合实际业务，根据由外部传入的`平台上下文（组件运行环境，配置端或者应用端）`进行渲染和交互。

同时会受到以下方面的影响：

#### 4.2.1. 样式框架影响

接入平台的组件将运行在平台之中，所以也将会收到平台的样式框架的影响，以下为样式框架的依赖：

1. `tailwind.css` 最基本的样式框架，不依赖任何组件，作为平台基本的样式支持
2. `antd` 以后考虑替换方案替换该 UI 库
3. `deer-ui` 以后考虑替换方案替换该 UI 库

#### 4.2.2. UI 框架影响

1. 平台提供基础的 UI 隔离架构 `@infra/ui`，其中包含通用的基础组件可以选择
2. 可以由接入的自身决定使用什么 UI 框架，在可控的范围内放开技术选型，后续再做技术收敛

### 4.3. 平台提供的能力

页面设计器主要是提供两个核心功能：

1. 提供一份描述页面布局、业务逻辑的数据结构
2. 提供更改页面数据结构的 API

### 4.4. 平台组件接入图解

平台组件接入概览

![img](assets/平台组件接入概览-总览.jpg)

平台组件接入流程

![img](assets/平台组件接入概览-平台组件接入.jpg)

平台组件的运作机制

![img](assets/平台组件接入概览-平台运行机制.jpg)

### 4.5. 平台组件 & 属性项的接入概览

1. 平台组件接入
   1. 创建平台组件工程
   2. 定义组件的元数据描述
   3. 创建组件 (widget)
2. 属性项接入
   1. 创建属性项工程
   2. 定义属性项元数据描述
   3. 编写属性项编辑的业务逻辑
3. 建立平台组件 - 属性项的关联关系
4. 将平台组件和属性项注册到对外提供的服务接口
   1. 将平台组件分组信息注册到组件面板
   2. 将属性项分组信息注册到属性项分组数据中
   3. 将组件和属性依赖关系注册到 loader 获取服务中
5. 检查是否接入成功
   1. 启动必要服务
      1. 在本地启动配置前端（[参考](../README.md)）
      2. 在本地启动应用前端，参考同上
      3. 在本地启动 platform-web-server，参考同上
   2. 打开配置前端，如果没有其他，打开 [http://localhost:6679/](http://localhost:6679/)
      1. 选择一个应用（如果没有现成应用，则需要创建应用。这里假设已经存在应用。）。
      2. 编辑其中的一个页面（如果没有现成页面，则需要创建页面。这里假设已经存在页面。）。
      3. 在左侧的「控件类型」面板查看是否存在接入的组件，如果有，则拖动进入中间的画布区域。
      4. 点击右上方的「预览」按钮，查看应用端是否正常显示。
   3. 如果上述步骤没有问题，则表示接入成功。否则，需要进一步排查错误。
6. 接入异常排查
   1. TODO

> 准备就绪，即将开始

---

## 5. 平台组件接入

### 5.1. 创建平台组件工程

工作目录： `packages/platform-widget-hub`。__未来在基础框架成熟后，将在单独的工程中开发平台组件。__

我们将平台组件当成一个完整的工程来看待，以下是平台组件工程包含的文件：

1. `package.json` 描述平台组件工程的文件
2. `spec.tsx` 接入规格，定义组件的元数据、可编辑属性等
3. `index.ts` 索引文件
4. `其他.tsx` 可以编写任意的组件，交给 `spec.tsx` 使用

创建 `package.json`。可以根据实际情况编写，可以使用三方库，自由度较高，以下我们以`单行输入框 FormInput`为例子：

```json
{
  "name": "@platform-widget/form-input",
  "description": "表单单行输入框",
  "version": "0.0.1",
  "author": "xxx",
  "license": "MIT",
  "dependencies": {}
}
```

### 5.2. 定义组件的元数据描述

参考：[packages/platform-widget-hub/FormInput/spec.tsx](../packages/platform-widget-hub/FormInput/spec.tsx)。__点击进入查看 ts 定义，有更详细的注释。__

创建 `spec.tsx`。我们将基于装饰器（decorator）的方式来约束接入到平台的组件：

```tsx
import React from 'react';
import { PlatformWidget, PlatformWidgetComp, WidgetEntityState, WidgetActions } from '@platform-widget-access/spec';
import { FormInputComp } from './comp';

@PlatformWidget({
  name: 'FormInput',
  // 定义可被编辑的属性
  editableProps: {
    title: {
      type: "string"
    },
    labelColor: {
      type: "string"
    },
    realVal: {
      type: "string"
    },
  }
})
export class FormInput implements PlatformWidgetComp {
  constructor(widgetMeta) {
    console.log(widgetMeta);
  }

  printA() {
    console.log('A');
  }

  render(widgetState: WidgetEntityState, widgetActions: WidgetActions) {
    return (
      <FormInputComp {...widgetState} />
    );
  }
}
```

`@spec/platform-widget-access` 提供平台组件接入的规范，拥有基本约束、组件元数据声明等检查函数。

### 5.3. 创建组件 (widget)

创建 comp.tsx。这是约定的组件入口，编写 react 组件

```tsx
/**
 * 在 form 表单中有标题的 Input 组件
 */
import React from 'react';
import { Input } from 'antd';

/**
 * FormInput 必须的 props
 */
export interface FormInputCompProps {
  title: string
  /** 默认值 */
  realVal: string
  labelColor: string
}

export const FormInputComp: React.FC<FormInputCompProps> = (props) => {
  const {
    title,
    labelColor,
    realVal,
  } = props;

  return (
    <div>
      <div
        style={{
          color: labelColor
        }}
      >
        {title}
      </div>
      <Input value={realVal} style={{ width: 300 }} />
    </div>
  );
};
```

添加索引文件 index.ts：

```ts
export * from './spec.tsx'
```

可以根据实际情况，将 `comp.tsx` 中的组件切割为多个组件

---

## 6. 属性项接入

工作目录： `packages/platform-widget-prop-item-hub`。__未来在基础框架成熟后，将在单独的工程中开发属性项。__

### 6.1. 创建属性项工程

参考：[packages/platform-widget-prop-item-hub/TitleHelper/spec.tsx](../packages/platform-widget-prop-item-hub/TitleHelper/spec.tsx)。__点击进入查看 ts 定义，有更详细的注释。__

同样的，我们将属性项也当成一个完整的工程来看待，以下是属性项工程包含的文件：

1. `package.json` 描述平台组件工程的文件
2. `spec.tsx` 接入规格，定义组件的元数据、可编辑属性等
3. `index.ts` 索引文件
4. `其他.tsx` 可以编写任意的组件，交给 `spec.tsx` 使用

### 6.2. 定义属性项元数据描述

创建 package.json。可以根据实际情况填写，可以ay依赖三方库，自由度较高，以下以`标题 Title`为例：

```json
{
  "name": "@platform-widget-prop-item/title-helper",
  "description": "标题属性编辑",
  "version": "0.0.1",
  "author": "xxx",
  "license": "MIT",
  "dependencies": {}
}
```

### 6.3. 定义属性项元数据描述

创建 spec.tsx。

```tsx
import React, { useEffect } from 'react';
import { PropItem, PropItemRenderContext } from '@platform-widget-access/spec';
import { TitleEditorComp } from './comp';

@PropItem({
  id: 'prop_title_value',
  name: 'PropTitle',
  label: '标题',
  whichAttr: ['title', 'field'],
  defaultValues: {
    title: '标题'
  },
})
export class TitleHelperSpec {
  render(ctx: PropItemRenderContext) {
    const { takeMeta, changeWidgetType } = ctx.platformCtx.meta;
    return (
      <TitleEditorComp {...ctx} takeMeta={takeMeta} />
    );
  }
}
```

### 6.4. 编写属性项编辑的业务逻辑

创建 comp.tsx。

```tsx
import React, { useEffect } from 'react';
import { Input } from '@infra/ui';
import { PropItemRenderContext } from '@platform-widget-access/spec';

export const TitleEditorComp: React.FC<PropItemRenderContext> = ({
  changeEntityState,
  editingWidgetState,
  platformCtx: {
    meta: {
      takeMeta
    }
  }
}) => {
  const { title, field } = editingWidgetState;
  const selectedField = takeMeta({
    metaAttr: 'schema',
    metaRefID: field
  });
  useEffect(() => {
    const nextTitle = selectedField?.column?.name;
    if (!nextTitle || nextTitle === title) return;
    changeEntityState({
      attr: 'title',
      value: nextTitle
    });
  }, [field]);
  return (
    <div>
      <Input
        value={title || ''}
        onChange={(value) => changeEntityState({
          attr: 'title',
          value
        })}
      />
    </div>
  );
};
```

创建索引文件 index.ts。

```tsx
export * from './spec';
```

---

## 7. 建立平台组件 - 属性项的关联关系

工作目录： `packages/platform-widget-access-prop-rely`。

参考：[packages/platform-widget-access-prop-rely/rely-meta/FormInput-meta.ts](../packages/platform-widget-access-prop-rely/rely-meta/FormInput-meta.ts)

```tsx
import { CreateWidgetPropItemRely } from "@platform-widget-access/spec";

export const DropdownSelectorMeta = CreateWidgetPropItemRely({
  id: 'widget-id-5',
  label: '下拉选择器',
  widgetRef: 'DropdownSelector',
  propItemsRely: {
    propItemRefs: [
      { propID: 'prop_widget_coding' },
      { propID: 'prop_datasource_selector' },
      { propID: 'prop_style_title_color' },
      {
        propID: 'prop_title_value',
        defaultValues: {
          title: '下拉选择'
        },
      },
      { propID: 'prop_field' },
      // { propID: 'prop_flex_config' },
    ]
  }
});
```

---

## 8. 将平台组件和属性项注册到对外提供的服务接口

工作目录： `packages/platform-widget-access-loader`。

分别在以下文件注册信息：

- [platform-widget-access-loader/refs-prop-item.ts](../packages/platform-widget-access-loader/refs-prop-item.ts) 属性项的引用注册
- [platform-widget-access-loader/refs-widget.ts](../packages/platform-widget-access-loader/refs-widget.ts) 平台组件的引用注册

### 8.1. 将平台组件分组信息注册到组件面板

编辑 [packages/platform-widget-access-loader/services/widget-grouping.ts](../packages/platform-widget-access-loader/services/widget-grouping.ts)

```ts
export const widgetPanelData: GroupPanelData = {
  title: '控件类型',
  type: 'dragableItems',
  itemsGroups: [
    {
      title: '通用',
      items: [
        'FormButton',
      ]
    },
    {
      title: '表单控件',
      items: [
        'FormInput',
        'Textarea',
        'DropdownSelector',
      ]
    },
    {
      title: '表格控件',
      items: [
        'NormalTable',
      ]
    },
    {
      title: '布局控件',
      items: [
        'FlexLayout'
      ]
    },
  ]
};
```

### 8.2. 将属性项分组信息注册到属性项分组数据中

编辑 `packages/platform-widget-access-loader/services/prop-grouping.ts`

```ts
export const propItemGroupingData: GroupPanelData[] = [
  {
    title: '属性',
    itemsGroups: [
      {
        title: '基本属性',
        items: [
          'prop_widget_coding',
          'prop_title_value',
          'prop_field',
          'prop_real_value',
          'prop_action_config',
          'prop_datasource_selector',
          'prop_widget_type',
          'prop_data_type',
          'prop_string_length',
          'prop_prompt_info',
          'prop_note_info',
          'prop_start_search',
          'prop_dropdown_multiple',

        ]
      },
      {
        title: '状态属性',
        items: [
        ]
      },
      {
        title: '数字属性',
        items: [
          'prop_number_max',
          'prop_number_min',
          'prop_number_radixPoint'
        ]
      },
      {
        title: '控件校验',
        items: [
          'prop_check_fixed_rule',
          'prop_check_custom_rule',
          'prop_check_error_tooltip'
        ]
      },
    ]
  },
  {
    title: '样式',
    itemsGroups: [
      {
        title: '样式属性',
        items: [
          'PropLabelColor',
        ]
      },
    ]
  },
  {
    title: '数据',
    itemsGroups: [
      {
        title: '控件校验',
        items: [
        ]
      },
    ]
  },
];
```

### 8.3. 将组件和属性依赖关系注册到 loader 获取服务中

编辑 `packages/platform-widget-access-loader/services/get-widget-rely-meta.ts`

```ts
import { WidgetTypeMetadataCollection } from "@engine/visual-editor/data-structure";
import {
  Widget, // 从这里导入
} from "@platform-widget-access/prop-item-rely";
import { ApiMock } from "./api-mock";

const tempArr = [
  Widget // 从这里导出
];
```

---

## 9. 页面数据结构和 API

| 术语 | 解释 |
|---|---|
| 页面数据结构 | 页面设计器设计页面最终产出的数据结构，用于存储组件、变量、业务关系描述等，以 json 的形式存储 |
| 平台 API | 提供修改平台数据能力的接口 |

### 9.1. 页面设计器的页面数据结构

概览：

```ts
const pageContent = {
  // 存储页面内容
  content: [],
  // 该页面的 id
  id: string,
  // 页面元数据描述，用于存储业务逻辑引用关系的数据节点
  meta: {},
  // 页面的名称
  name: string,
  // 页面 id，暂时无用
  pageID: string
}
```

#### 9.1.1. content

页面内容，用于描述页面如何布局，每个 widget 节点

#### 9.1.2. meta

TODO

```tsx
meta = {
  varRely: {

  },
  dataSource: {

  },
  actions: {

  },
}
```

### 9.2. 平台提供的 SDK

`@platform-widget-access/spec` 提供核心的接入规范，提供以下几种能力：

1. 组件接入：
   1. `PlatformWidget(meta)`
2. 属性项接入
   1. `PropItem(meta)`
3. 创建组件与属性项的依赖关系
   1. `CreateWidgetPropItemRely()`

```ts
import {
  CreateWidgetPropItemRely,
  PlatformWidget,
  PropItem,
} from "@platform-widget-access/spec";
// 具体用法参考 5～8 述章节
```

在属性项的 `render` 函数中，平台传入了 `PropItemRenderContext` ，提供属性项修改页面数据的能力：

```tsx
@PropItem({
  ...
})
export class TitleHelperSpec {
  render(ctx: PropItemRenderContext) {
    const { takeMeta, changeWidgetType } = ctx.platformCtx.meta;
    return (
      ...
    )
  }
}
```

[详情参考定义](../packages/provider-app-pages-hub/PageDesigner/platform-access/platform-ctx-types.ts)

---
