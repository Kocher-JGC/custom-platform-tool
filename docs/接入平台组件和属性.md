# 平台组件接入规则

## 1. Changelog

| 作者 | 更新日期 | 版本 | 更改内容 |
|---|---|---|---|
| 相杰 | 2020-11-16 | v1 | 初稿 |

## 2. 编写目的和范围

1. 一份详细的平台组件接入到平台的规范说明

---

## 3. 术语

| 术语 | 解释 |
|---|---|
| 平台组件 | 接入整个平台的组件，只需要接入一次，即可在配置端和应用端使用 |

---

## 4. 接入概览

1. 创建平台组件工程
   1. 定义组件的元数据描述
   2. 定义可被编辑的属性
2. 创建属性项工程
   1. 定义属性项元数据描述
   2. 编写属性项编辑的业务逻辑
3. 建立平台组件 - 属性项的关联关系
4. 将元数据注册到对外提供的服务接口
   1. 将平台组件分组信息注册到组件面板
   2. 将属性项分组信息注册到属性项分组数据中

### 4.1. 依赖包

在工程中，以下前缀的包对应不同的能力：

- platform-widget-* 组件开发相关
- platform-widget-access-* 组件接入平台相关

---

## 5. 创建平台组件工程

临时工作目录： `packages/platform-widget-hub`。未来在基础框架成熟后，将在单独的工程中开发平台组件。

我们将平台组件当成一个完整的工程来看待，以下是平台组件工程包含的文件：

1. `package.json` 描述平台组件工程的文件
2. `spec.tsx` 接入规格，定义组件的元数据、可编辑属性等
3. `index.ts` 索引文件
4. `其他.tsx` 可以编写任意的组件，交给 `spec.tsx` 使用

### 5.1. package.json

可以根据实际情况填写，可以使用任意三方库，自由度很高

```json
{
  "name": "@platform-widget/dropdown-selector",
  "description": "下拉组件",
  "version": "0.0.1",
  "author": "xxx",
  "license": "MIT",
  "dependencies": {
  }
}
```

### 5.2. spec.tsx

我们尝试了几种规范约束的方式，最终决定采用装饰器（decorator）的方式来约束、声明平台组件：

```tsx
import React from 'react';
import { PlatformWidget, PlatformWidgetComp, WidgetEntityState } from '@platform-widget-access/spec';
import { FormInputComp } from '.';

@PlatformWidget({
  name: 'FormInput',
  editableProps: {
    title: {
      type: "string"
    },
    labelColor: {
      type: "string"
    },
    realVal: {
      type: "string"
    },
  }
})
export class FormInput implements PlatformWidgetComp {
  constructor(widgetMeta) {
    console.log(widgetMeta);
  }

  printA() {
    console.log('A');
  }

  render(widgetState: WidgetEntityState) {
    return (
      <FormInputComp {...widgetState} />
    );
  }
}
```

`@spec/platform-widget-access` 是内部的库，提供平台组件接入的规范，拥有基本约束、组件元数据声明等检查函数。

### 5.3. index.ts

这是一份简单的索引文件：

```ts
export * from './spec.tsx'
```

### 5.4. 其他组件

可以根据实际情况，根据具体业务编写业务组件

---

## 6. 创建属性项工程

临时工作目录： `packages/platform-widget-prop-item-hub`。未来在基础框架成熟后，将在单独的工程中开发属性项。

同样的，我们将属性项也当成一个完整的工程来看待，以下是属性项工程包含的文件：

1. `package.json` 描述平台组件工程的文件
2. `spec.tsx` 接入规格，定义组件的元数据、可编辑属性等
3. `index.ts` 索引文件
4. `其他.tsx` 可以编写任意的组件，交给 `spec.tsx` 使用

### 6.1. package.json

可以根据实际情况填写，可以使用任意三方库，自由度很高

```json
{
  "name": "@platform-widget/dropdown-selector",
  "description": "下拉组件",
  "version": "0.0.1",
  "author": "xxx",
  "license": "MIT",
  "dependencies": {
  }
}
```

### 6.2. spec.tsx

```tsx
import React from 'react';
import { PropItem, PropItemRenderContext } from '@platform-widget-access/spec';
import { TitleEditorComp } from './comp';

/** 属性项编辑的组件属性 */
const whichAttr = 'title';

@PropItem({
  id: 'prop_title_value',
  name: 'PropTitle',
  label: '标题',
  whichAttr: ['title', 'field'],
  defaultValues: {
    title: '标题'
  },
})
export class TitleHelperSpec {
  render(ctx: PropItemRenderContext) {
    return (
      <TitleEditorComp {...ctx} />
    );
  }
}
```

---

## 7. 建立平台组件 - 属性项的关联关系

临时工作目录： `packages/platform-widget-access-prop-rely`。

```tsx
import { CreateWidgetPropItemRely } from "@platform-widget-access/spec";

export const DropdownSelectorMeta = CreateWidgetPropItemRely({
  id: 'widget-id-5',
  label: '下拉选择器',
  widgetRef: 'DropdownSelector',
  propItemsRely: {
    propItemRefs: [
      { propID: 'prop_widget_coding' },
      { propID: 'prop_datasource_selector' },
      { propID: 'prop_style_title_color' },
      {
        propID: 'prop_title_value',
        defaultValues: {
          title: '下拉选择'
        },
      },
      { propID: 'prop_field' },
      // { propID: 'prop_flex_config' },
    ]
  }
});
```

---

## 8. 将元数据注册到对外提供的服务接口

临时工作目录： `packages/platform-widget-access-loader`。

分别在以下引用文件注册：

- platform-widget-access-loader/refs-prop-item 属性项的引用注册的入口
- platform-widget-access-loader/refs-widget 平台组件的引用注册的入口

### 8.1. 将平台组件分组信息注册到组件面板

编辑 `packages/platform-widget-access-loader/services/widget-grouping.ts`

```ts
export const widgetPanelData: GroupPanelData = {
  title: '控件类型',
  type: 'dragableItems',
  itemsGroups: [
    {
      title: '通用',
      items: [
        'FormButton',
      ]
    },
    {
      title: '表单控件',
      items: [
        'FormInput',
        'Textarea',
        'DropdownSelector',
      ]
    },
    {
      title: '表格控件',
      items: [
        'NormalTable',
      ]
    },
    {
      title: '布局控件',
      items: [
        'FlexLayout'
      ]
    },
  ]
};
```

### 8.2. 将属性项分组信息注册到属性项分组数据中

编辑 `packages/platform-widget-access-loader/services/prop-grouping.ts`

```ts
export const propItemGroupingData: GroupPanelData[] = [
  {
    title: '属性',
    itemsGroups: [
      {
        title: '基本属性',
        items: [
          'prop_widget_coding',
          'prop_title_value',
          'prop_field',
          'prop_real_value',
          'prop_action_config',
          'prop_datasource_selector',
          'prop_widget_type',
          'prop_data_type',
          'prop_string_length',
          'prop_prompt_info',
          'prop_note_info',
          'prop_start_search',
          'prop_dropdown_multiple',

        ]
      },
      {
        title: '状态属性',
        items: [
        ]
      },
      {
        title: '数字属性',
        items: [
          'prop_number_max',
          'prop_number_min',
          'prop_number_radixPoint'
        ]
      },
      {
        title: '控件校验',
        items: [
          'prop_check_fixed_rule',
          'prop_check_custom_rule',
          'prop_check_tooltip'
        ]
      },
    ]
  },
  {
    title: '样式',
    itemsGroups: [
      {
        title: '样式属性',
        items: [
          'PropLabelColor',
        ]
      },
    ]
  },
  {
    title: '数据',
    itemsGroups: [
      {
        title: '控件校验',
        items: [
        ]
      },
    ]
  },
];
```

### 8.3. 将组件和属性依赖关系注册到 loader 获取服务中

编辑 `packages/platform-widget-access-loader/services/get-widget-rely-meta.ts`

```ts
import { WidgetTypeMetadataCollection } from "@engine/visual-editor/data-structure";
import {
  Widget, // 从这里导入
} from "@platform-widget-access/prop-item-rely";
import { ApiMock } from "./api-mock";

const tempArr = [
  Widget // 从这里导出
];
```

---

## 9. API

`@platform-widget-access/spec` 提供核心的接入规范，提供以下几种能力：

1. 组件约定
2. 获取组件实例状态
3. 更新组件状态的接口
4. 更新页面元数据的接口
5. 页面设计器提供的 UI 上下文

---
